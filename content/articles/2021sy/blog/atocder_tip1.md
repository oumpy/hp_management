Title: 競プロ備忘録1
Date: 2022.2.27
Modified: 22022.2.27
Tags: 競技プログラミング
Author: 富本

<!-- PELICAN_BEGIN_SUMMARY -->
ゼータ・メビウス変換について去年の夏にやったことを備忘録として残そうと思います。
<!-- PELICAN_END_SUMMARY -->


ゼータ・メビウス変換は競プロではいろいろな文脈で使われるため混乱する要素が多いですが理解してしまうと意外と単純で、たまにABCにも出たりする([ABC162のE問題](https://atcoder.jp/contests/abc162/tasks/abc162_e)や[ABC206のE問題](https://atcoder.jp/contests/abc206/tasks/abc206_e)など)ので、ややマニアックではありますが知っておいて損はないと思います。<br>
使われる文脈ごとに分類しているので、全体像が見えやすいと思います。

### ゼータ・メビウス変換の定義

X=[a_0,b_0)*[a_1,b_1)*...*[a_n-1,b_n-1)として、Xの元x=(x_0,x_1,...,x_n-1)に対してf(x)が定義されているとします。<br>
Xの元x=(x_0,x_1,...,x_n-1)に対して、<br>
g(x)=(y_i<=x_i(0<=i<=n-1)となるようなXの元y=(y_0,y_1,...,y_n-1)すべてについてのf(y)の和)<br>
と定義します。<br>
N=2の場合は長方形、N=3の場合は直方体をイメージするとわかりやすいと思います。<br>
f→gをゼータ変換、g→fをメビウス変換といいます。<br>
直感的にいうと、ゼータ変換はn次元の累積和をとることで、メビウス変換はn次元の差分をとることです。<br>
ちなみに、ゼータ関数をかけることは、ディリクレ級数においてゼータ変換を行うことに相当します。<br>
たとえばfという名前で次元がnのnp.arrayをゼータ変換したければ、<br>
```python
for i in range(n):
    np.cumsum(f,axis=i,out=f)
```
とすればいいです。
二次元配列lstの二次元累積和をとるときに<br>
```python
for i in range(N):
    for j in range(1,N):
        lst[i][j]+=lst[i][j-1]
for i in range(1,N):
    for j in range(N):
        lst[i][j]+=lst[i-1][j]
```
とするのを2次元からn次元に拡張していると考えるとイメージしやすいと思います。


###　 ゼータ・メビウス変換の利用

#### 　1:高速ゼータ・メビウス変換

長さ2^nのリストAが与えられたときに、B[i]=(i⊇jとなるようなすべてのjについてのA[j]の和)(0<=i<=2^n-1)を求めたいとします。<br>
ただし、⊇はビット整数が表す集合についての意味で、i⊇jはi&j==iと同じです。

まず、普通にやる方法は、
```python
B=[0]*(1<<n)
for i in range(1<<n):
    for j in range(1<<n):
        if i&j==i:
            B[i]+=A[j]
```
で、これの計算量は(4^n)です。
3のn乗bitdpでおなじみの工夫をすると、
```python
for i in range(1<<n):
    j=i
    while j:
        B[i]+=A[j]
        j-=1
        j&=i
    B[i]+=A[0]
```
とできて、これの計算量はO(3^n)です。
2^n以下のビット整数を[0,2)^nと解釈すると、BはAのゼータ変換になっています。先ほどと同様に、
```python
B=[a for a in A]
for bit in range(n):
    for i in range(1<<n):
        if i>>bit&1:
            B[i]+=B[i^1<<bit]
```
とすることで計算量をO(n*2^n)にできます。
ビット整数以外にも、添え字を何かの直積と見なすことでゼータ変換に解釈できる例はいくつかあります。
また、ゼータ変換と逆の操作を逆の順番に行うことでメビウス変換も高速に行うことができます。

#### 　2:包除原理としての性質

A:[0,∞)*2→(-∞,∞)をゼータ変換したものをBとします。
任意の0<=i,0<=jについてB[i,j]は簡単に求まるとして、A[a,b]を求めたいとします。
先ほどと同様に0<=i<=a,0<=j<=bについてB[i,j]を求めてから高速メビウス変換を行うとA[i,j]を求めることができますが、計算量がO(a*b)かかってしまいます。
包除原理を用いると、A[a,b]はBの値を高々4個足し引きすることで求めることができます。(たとえば、A[6,10]=B[6,10]-B[5,10]-B[6,9]+B[5,9])
一つ目との違いは、A,Bの値をすべて求める必要がないことですが、その代わり、(求まるAの値の個数)/(求める必要のあるBの値の個数)は少なくなってしまいます。
リストAとリストBは、<br>
B[i]=(iがjの倍数となるようなすべてのjについてのA[j]の和)<br>
を満たすとします。
各素数で割り切れる回数をベクトル化することで、BはAのゼータ変換と見なせます。
たとえば、10は(1,0,1,0,0,...)、18は(1,2,0,0,0...)と解釈できます。
このように考えると、メビウスの反転公式なども直感的に理解することができます。

#### 　3:畳み込みの高速化

リストA,B(:[0,N)→R)と二項演算op(:[0,N)^2→[0,N))があったときに、
C[k]=(op(i,j)=kとなるようなすべてのi,jについてのA[i]*B[j]の和)<br>
となるようなC(:[0,N)→R)を高速に求めたいといます。
たとえばopが+のときはフーリエ変換でO(NlogN)で求められますし、opが*のときは適切に枝刈りすることでO(NlogN)で求められます。
opがmaxのときを考えます。Cの定義式は、<br>
ζ(A)[i]*ζ(B)[i]=ζ(C)[i](0<=i<=N-1)<br>
と言い換えられます。
AとBをゼータ変換してN回積を求め、メビウス変換することでCをO(N)で求めることができます。
これは次元を増やして拡張することができて、<br>
X=[a_0,b_0)*[a_1,b_1)*...*[a_n-1,b_n-1)としたときに、Xの元x=(x_0,x_1,...,x_n-1),y=(y_0,y_1,...,y_n-1)に対して
max(x,y)=(max(x_0,y_0),max(x_1,y_1),...,max(x_n-1,y_n-1))<br>
と定義すると、上記の式を満たすことがわかります。

各素数で割り切れる回数をベクトル化して考えると、lcmはmaxに相当し、op=lcmの場合の畳み込みは高速に計算できることがわかります。(計算量はO(NloglogN))<br>
ビット整数をベクトルとして考えると、orはmaxに相当し、op=orの場合の畳み込みも高速に計算できることがわかります。(計算量はO(NlogN))<br>
op=minのときもop=maxの場合とほとんど同様に計算できるので、op=min,gcd,andの場合も高速に計算できることがわかります。


###　まとめ
以上をまとめると、ゼータ・メビウス変換には3つの側面があります。<br>

1. 累積和、差分としての性質で、これにより(すべてのx(∈X)についてのf(x))と(すべてのx(∈X)についてのg(x))をO(|X|*Xの次元)で相互変換できます。
2. 包除原理としての性質で、特定のx(∈X)についてf(x)を求めたい場合、いくつかのg(y)を求め、それらに1か-1をかけて足すことでf(x)を求めることができます。メビウス関数をかけて足すことは、これに相当します。
3. 特殊な(max,minに相当する)演算についての畳み込み(A*B=C)は、AとBを高速ゼータ変換し、C[x]=A[x]*B[x]となるようにCを求めた後、Cを高速メビウス変換することで高速に求めることができます。